// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const getAverageTimeToEatPerClientQuantity = `-- name: GetAverageTimeToEatPerClientQuantity :many

SELECT
	c.numPersonas,
	AVERAGE(MAX(p.fecha) OVER (PARTITION BY c.numCuenta) - MIN(p.fecha) OVER (PARTITION by c.numCuenta)) as timeToEat
FROM cuenta c
	LEFT JOIN pedido p ON p.numCuenta = c.numCuenta
WHERE c.estaCerrada AND p.fecha BETWEEN $1 AND $2
GROUP BY numPersonas
`

type GetAverageTimeToEatPerClientQuantityParams struct {
	Fecha   time.Time
	Fecha_2 time.Time
}

type GetAverageTimeToEatPerClientQuantityRow struct {
	Numpersonas int32
	Timetoeat   interface{}
}

// 3. Promedio de tiempo en que se tardan los clientes en comer, agrupando la cantidad de
// personas comiendo, por ejemplo: 2 personas: 1 hora 10 minutos, 3 personas: 1 hora 15
// minutos, etc. entre un rango de fechas solicitadas al usuario.
func (q *Queries) GetAverageTimeToEatPerClientQuantity(ctx context.Context, arg GetAverageTimeToEatPerClientQuantityParams) ([]GetAverageTimeToEatPerClientQuantityRow, error) {
	rows, err := q.db.QueryContext(ctx, getAverageTimeToEatPerClientQuantity, arg.Fecha, arg.Fecha_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAverageTimeToEatPerClientQuantityRow
	for rows.Next() {
		var i GetAverageTimeToEatPerClientQuantityRow
		if err := rows.Scan(&i.Numpersonas, &i.Timetoeat); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getComplaintsForDishBetween = `-- name: GetComplaintsForDishBetween :many

SELECT cliente, gravedad, motivo, fecha, empleado, item
FROM queja
WHERE item = $1 AND fecha $2 AND $3
`

type GetComplaintsForDishBetweenParams struct {
	Item    sql.NullInt32
	Column2 interface{}
	Column3 interface{}
}

// 5. Reporte de las quejas agrupadas por plato para un rango de fechas solicitadas al usuario.
func (q *Queries) GetComplaintsForDishBetween(ctx context.Context, arg GetComplaintsForDishBetweenParams) ([]Queja, error) {
	rows, err := q.db.QueryContext(ctx, getComplaintsForDishBetween, arg.Item, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Queja
	for rows.Next() {
		var i Queja
		if err := rows.Scan(
			&i.Cliente,
			&i.Gravedad,
			&i.Motivo,
			&i.Fecha,
			&i.Empleado,
			&i.Item,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getComplaintsForEmployeeBetween = `-- name: GetComplaintsForEmployeeBetween :many

SELECT cliente, gravedad, motivo, fecha, empleado, item
FROM queja 
WHERE empleado = $1 AND fecha BETWEEN $2 AND $3
`

type GetComplaintsForEmployeeBetweenParams struct {
	Empleado sql.NullInt32
	Fecha    time.Time
	Fecha_2  time.Time
}

// 4. Reporte de las quejas agrupadas por persona para un rango de fechas solicitadas al usuario.
func (q *Queries) GetComplaintsForEmployeeBetween(ctx context.Context, arg GetComplaintsForEmployeeBetweenParams) ([]Queja, error) {
	rows, err := q.db.QueryContext(ctx, getComplaintsForEmployeeBetween, arg.Empleado, arg.Fecha, arg.Fecha_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Queja
	for rows.Next() {
		var i Queja
		if err := rows.Scan(
			&i.Cliente,
			&i.Gravedad,
			&i.Motivo,
			&i.Fecha,
			&i.Empleado,
			&i.Item,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEfficiencyReport = `-- name: GetEfficiencyReport :many


SELECT 
	en.empleado,
	EXTRACT(MONTH from en.fecha) as mes,
	AVG(e.gradoAmabilidad),
	AVG(e.gradoExactitud) 
FROM encuesta en
	INNER JOIN empleado em ON em.id = en.empleado
	INNER JOIN puesto p ON em.puesto = p.id
WHERE 
	em.puesto = 'Mesero' AND
	en.fecha BETWEEN NOW() AND NOW() - interval '6 months'
GROUP BY en.empleado, mes
`

type GetEfficiencyReportRow struct {
	Empleado int32
	Mes      string
	Avg      float64
	Avg_2    float64
}

// 6. Reporte de eficiencia de meseros mostrando los resultados de las encuestas, agrupado
// por personas y por mes para los últimos 6 meses.
// | Persona | Mes | avgAmabilidad | avgExactirud |
func (q *Queries) GetEfficiencyReport(ctx context.Context) ([]GetEfficiencyReportRow, error) {
	rows, err := q.db.QueryContext(ctx, getEfficiencyReport)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEfficiencyReportRow
	for rows.Next() {
		var i GetEfficiencyReportRow
		if err := rows.Scan(
			&i.Empleado,
			&i.Mes,
			&i.Avg,
			&i.Avg_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostFamousDishesBetween = `-- name: GetMostFamousDishesBetween :many

SELECT p.item, i.nombre, i.descripcion, COUNT(p) as count
FROM pedido p
	RIGHT JOIN itemMenu i on p.item = i.id
WHERE p.fecha BETWEEN $1 AND $2 
GROUP BY p.item, i.nombre, i.descripcion
ORDER BY count DESC
`

type GetMostFamousDishesBetweenParams struct {
	Fecha   time.Time
	Fecha_2 time.Time
}

type GetMostFamousDishesBetweenRow struct {
	Item        sql.NullInt32
	Nombre      string
	Descripcion string
	Count       int64
}

// 1. Reporte de los platos más pedidos por los clientes en un rango de fechas solicitadas al usuario.
func (q *Queries) GetMostFamousDishesBetween(ctx context.Context, arg GetMostFamousDishesBetweenParams) ([]GetMostFamousDishesBetweenRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostFamousDishesBetween, arg.Fecha, arg.Fecha_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostFamousDishesBetweenRow
	for rows.Next() {
		var i GetMostFamousDishesBetweenRow
		if err := rows.Scan(
			&i.Item,
			&i.Nombre,
			&i.Descripcion,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoleOfUser = `-- name: GetRoleOfUser :many

SELECT 
	tu.nombre AS tipo_usuario
FROM 
	usuario u
JOIN 
	tipoUsuario tu ON u.tipo = tu.id
WHERE 
	u.nombre = $1 AND u.contraseña = $2
`

type GetRoleOfUserParams struct {
	Nombre     string
	Contraseña string
}

// 0. Saber el rol de la persona a partir del usuario y contraseña ingresados por el usuario.
func (q *Queries) GetRoleOfUser(ctx context.Context, arg GetRoleOfUserParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getRoleOfUser, arg.Nombre, arg.Contraseña)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tipo_usuario string
		if err := rows.Scan(&tipo_usuario); err != nil {
			return nil, err
		}
		items = append(items, tipo_usuario)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRushHourBetween = `-- name: GetRushHourBetween :one

SELECT EXTRACT(hour from p.fecha) as horario, COUNT(*) as count
FROM pedido p
WHERE p.fecha BETWEEN $1 AND $2
GROUP BY horario
ORDER BY count DESC
LIMIT 1
`

type GetRushHourBetweenParams struct {
	Fecha   time.Time
	Fecha_2 time.Time
}

type GetRushHourBetweenRow struct {
	Horario string
	Count   int64
}

// 2. Horario en el que se ingresan más pedidos entre un rango de fechas solicitadas al usuario.
func (q *Queries) GetRushHourBetween(ctx context.Context, arg GetRushHourBetweenParams) (GetRushHourBetweenRow, error) {
	row := q.db.QueryRowContext(ctx, getRushHourBetween, arg.Fecha, arg.Fecha_2)
	var i GetRushHourBetweenRow
	err := row.Scan(&i.Horario, &i.Count)
	return i, err
}
